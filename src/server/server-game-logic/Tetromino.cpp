#include "Tetromino.hpp"

Tetromino::Tetromino(const Position2D startPos, const PieceType type,
                     const tetroShape &shape)
    : position(startPos), pieceType(type), shape(shape) {
    // this is a constructor for the tetromino class that initializes the
    // position of the tetromino to the start position, the type of the
    // tetromino to the type given in the constructor and the shape of the
    // tetromino to the shape given in the constructor
}

Tetromino::Tetromino(const Position2D startPos, const PieceType type)
    : position(startPos), pieceType(type), shape(generateShapeByType(type)) {
    // this is the default constructor for the tetromino class
    // it initializes the position of the tetromino to the start position
    // and the shape of the tetromino to the shape generated by the type
    // of the tetromino
}

Tetromino::Tetromino(const PieceType type)
    : position(DEFAULT_POSITION), pieceType(type),
      shape(generateShapeByType(type)) {
    // this is a constructor for the tetromino class that initializes the
    // position of the tetromino to DEFAULT_POSITION ({0, 0})
}

bool
Tetromino::operator==(const Tetromino &other) const {
    // this function checks if two tetrominos are equal
    // purpose of this is mainly bcs of finding tetro in vectors (to delete
    // them)

    return (position.x == other.position.x && position.y == other.position.y) &&
           shape == other.shape;
}

void
Tetromino::reset() {
    // this function resets the tetromino to its default position and original
    // shape

    setPosition(DEFAULT_POSITION);
    setShape(generateShapeByType(pieceType));
}

Position2D
Tetromino::getPosition() const {
    return position;
}

PieceType
Tetromino::getPieceType() const {
    return pieceType;
}

const tetroShape &
Tetromino::getShape() const {
    return shape;
}

void
Tetromino::setPieceType(const PieceType newType) {
    pieceType = newType;
    setShape(generateShapeByType(newType));
}

void
Tetromino::setPosition(const Position2D &newPosition) {
    position = newPosition;
}

void
Tetromino::setShape(const tetroShape &newShape) {
    shape = newShape;
}

Position2D
Tetromino::getMovePosition(const Action move) const {
    // this function returns the new position of the tetromino after a move
    // action is applied to it (theoretically, before actually moving it) if the
    // action is invalid, it throws an exception

    Position2D newPos = position;

    switch (move) {
        case Action::MoveLeft:
            newPos.x -= 1;
            break;
        case Action::MoveRight:
            newPos.x += 1;
            break;
        case Action::MoveDown:
            newPos.y += 1;
            break;
        default:
            throw std::invalid_argument("Invalid move action");
    }

    return newPos;
}

tetroShape
Tetromino::getRotateShape(const Action rotation) const {
    // this function returns the shape of the tetromino after a rotation action
    // is applied to it (theoretically, before actually rotating it)

    // if no rotation is needed, return the original shape
    if (rotation == Action::None) {
        return shape;
    }

    // get the size of the shape (they're always square)
    const int n = static_cast<int>(shape.size());
    if (n == 0 || n == 1) {
        return shape;
    }

    // create an empty matrix for the rotated shape
    tetroShape rotatedShape(n, std::vector<bool>(n, false));

    // for each cell in the shape, rotate it and put it in the new matrix
    // algorithm ruleset was inspired from
    // https://gamedev.stackexchange.com/questions/208367/how-is-rotation-defined-in-a-tetris-game

    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < n; ++j) {
            if (rotation == Action::RotateRight) {
                // rotate the cell 90 degrees clockwise
                rotatedShape[j][n - 1 - i] = shape[i][j];
            } else if (rotation == Action::RotateLeft) {
                // rotate the cell 90 degrees counterclockwise
                rotatedShape[n - 1 - j][i] = shape[i][j];
            } else {
                throw std::invalid_argument("Invalid rotation action");
            }
        }
    }

    return rotatedShape;
}

std::vector<Position2D>
Tetromino::getAbsoluteCoordinates(
    const std::optional<Position2D> topLeft,
    const std::optional<tetroShape> &shapeOverride) const {
    // this function returns the absolute coordinates of the tetromino
    // if a top left position is provided, the coordinates are calculated from
    // that position if a shape override is provided, the coordinates are
    // calculated from that shape

    // if a top left position is provided, use it, otherwise use the default
    // position
    auto [x, y] = topLeft.has_value() ? topLeft.value() : position;

    // if a shape override is provided, use it, otherwise use the default shape
    const tetroShape &usedShape =
            shapeOverride.has_value() ? shapeOverride.value() : shape;

    // calculate the shape size (they're always square)
    const int n = static_cast<int>(usedShape.size());

    // create a list of coordinates for the tetromino
    std::vector<Position2D> coords;

    // for each cell in the shape, calculate the absolute position and add it to
    // the list
    for (int rel_y = 0; rel_y < n; ++rel_y) {
        for (int rel_x = 0; rel_x < n; ++rel_x) {
            // if the cell is filled, calculate the absolute position
            if (usedShape[rel_y][rel_x]) {
                coords.push_back(Position2D{x + rel_x, y + rel_y});
            }
        }
    }

    return coords;
}

tetroShape
Tetromino::generateShapeByType(const PieceType type) {
    switch (type) {
        case PieceType::I:
            return {
                {false, false, false, false},
                {true, true, true, true},
                {false, false, false, false},
                {false, false, false, false},
            };

        case PieceType::O:
            return {
                {true, true},
                {true, true},
            };

        case PieceType::T:
            return {
                {false, true, false},
                {true, true, true},
                {false, false, false},
            };

        case PieceType::S:
            return {
                {false, true, true},
                {true, true, false},
                {false, false, false},
            };

        case PieceType::Z:
            return {
                {true, true, false},
                {false, true, true},
                {false, false, false},
            };

        case PieceType::J:
            return {
                {true, false, false},
                {true, true, true},
                {false, false, false},
            };

        case PieceType::L:
            return {
                {false, false, true},
                {true, true, true},
                {false, false, false},
            };

        case PieceType::Single:
            return {{true}};

        default:
            throw std::invalid_argument("Invalid piece type");
    }
}
